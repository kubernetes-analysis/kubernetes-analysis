#!/usr/bin/env python3
import argparse
import logging
from typing import Any

import src.log as log
from src.data import Data, Filter
from src.plot import Plot


def main():
    args = parse_args()
    log.setup(logging.INFO)
    Plot.init()

    # Parse the data
    data = Data(parse_nlp=args.parse_nlp)

    filter_text = "issues and PRs"
    if args.pull_requests:
        logging.info("Filtering pull requests only")
        filter_text = "PRs"
        data.filter = Filter.PULL_REQUESTS

    if args.issues:
        logging.info("Filtering issues only")
        filter_text = "issues"
        data.filter = Filter.ISSUES

    # Created over time
    if args.created:
        plot = Plot(data.created_time_series())
        x = plot.time("Created %s over time" % filter_text)
        plot.annotate_chunked(x)

    # Closed over time
    if args.closed:
        plot = Plot(data.closed_time_series())
        x = plot.time("Closed %s over time" % filter_text)
        plot.annotate_chunked(x)

    # Created vs Closed over time
    if args.created_vs_closed:
        plot = Plot(data.created_vs_closed_time_series())
        x = plot.time("Created vs closed %s over time" % filter_text)
        plot.annotate_chunked(x)

    if args.labels_by_name or args.labels_by_group or (args.users_by_created or
                                                       args.users_by_closed):
        data.include_regex = args.include
        data.exclude_regex = args.exclude

    # Label usage by name
    if args.labels_by_name:
        series = data.label_name_usage_series()
        plot = Plot(series)
        logging.info("Got %d distinct labels and %d results", len(series),
                     sum(series))
        logging.debug("Results:\n%s", series)
        plot.barh("Label usage by name for %s" % filter_text, args.count)

    # Label usage by name
    if args.labels_by_group:
        series = data.label_group_usage_series()
        plot = Plot(series)
        logging.info("Got %d distinct label groups and %d results",
                     len(series), sum(series))
        logging.debug("Results:\n%s", series)
        plot.barh("Label usage by label group for %s" % filter_text,
                  args.count)

    # Created by user
    if args.users_by_created:
        series = data.user_created_series()
        plot = Plot(series)
        logging.info("Got %d distinct users and %d results", len(series),
                     sum(series))
        logging.debug("Results:\n%s", series)
        plot.barh("Created by user for %s" % filter_text, args.count)

    # Closed by user
    if args.users_by_closed:
        series = data.user_closed_series()
        plot = Plot(series)
        logging.info("Got %d distinct users and %d results", len(series),
                     sum(series))
        logging.debug("Results:\n%s", series)
        plot.barh("Closed by user for %s" % filter_text, args.count)

    logging.info("Done")

    if not args.no_plot_gtk:
        Plot.show()

    if args.save_svg:
        Plot.save()


def parse_args() -> Any:
    parser = argparse.ArgumentParser()
    parser.add_argument("--no-plot-gtk",
                        "-n",
                        action="store_true",
                        help="Do not plot as GTK window")

    parser.add_argument("--save-svg",
                        "-s",
                        action="store_true",
                        help="Save the plot as SVG file")

    parser.add_argument("--include",
                        "-l",
                        type=str,
                        metavar="FILTER",
                        help="Include labels or users by the provided regex")

    parser.add_argument("--exclude",
                        "-e",
                        type=str,
                        metavar="FILTER",
                        help="Exclude labels or users by the provided regex")

    parser.add_argument("--count",
                        "-c",
                        type=int,
                        metavar="COUNT",
                        default=25,
                        help="Display only the specified amount of labels")

    parser.add_argument("--parse-nlp",
                        "-r",
                        action="store_true",
                        help="Live parse NLP data")

    select_group = parser.add_mutually_exclusive_group()
    select_group.add_argument("--created",
                              "-1",
                              action="store_true",
                              help="show created issues/PRs over time")

    select_group.add_argument("--closed",
                              "-2",
                              action="store_true",
                              help="show closed issues/PRs over time")

    select_group.add_argument(
        "--created-vs-closed",
        "-3",
        action="store_true",
        help="show created vs closed issues/PRs over time")

    select_group.add_argument("--labels-by-name",
                              "-4",
                              action="store_true",
                              help="show use labels by name")

    select_group.add_argument("--labels-by-group",
                              "-5",
                              action="store_true",
                              help="show used labels by group")

    select_group.add_argument("--users-by-created",
                              "-6",
                              action="store_true",
                              help="show users by created issues/PRs")

    select_group.add_argument("--users-by-closed",
                              "-7",
                              action="store_true",
                              help="show users by closed issues/PRs")

    filter_group = parser.add_mutually_exclusive_group()
    filter_group.add_argument("--pull-requests",
                              "-p",
                              action="store_true",
                              help="filter PRs only")

    filter_group.add_argument("--issues",
                              "-i",
                              action="store_true",
                              help="filter issues only")

    return parser.parse_args()


if __name__ == "__main__":
    main()
